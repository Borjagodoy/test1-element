/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
export declare function html(strings: TemplateStringsArray, ...values: any[]): TemplateResult;
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
export declare class TemplateResult {
    template: Template;
    values: any[];
    constructor(template: Template, values: any[]);
}
/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 */
export declare function render(result: TemplateResult, container: Element | DocumentFragment): void;
/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */
export declare class TemplatePart {
    type: string;
    index: number;
    name: string | undefined;
    rawName: string | undefined;
    strings: string[] | undefined;
    constructor(type: string, index: number, name?: string | undefined, rawName?: string | undefined, strings?: string[] | undefined);
}
export declare class Template {
    private _strings;
    parts: TemplatePart[];
    element: HTMLTemplateElement;
    constructor(strings: TemplateStringsArray);
    private _parse();
    private _getTemplateHtml(strings);
}
export declare abstract class Part {
    instance: TemplateInstance;
    size?: number;
    constructor(instance: TemplateInstance);
    abstract setValue(value: any): void;
    protected _getValue(value: any): any;
}
export declare class AttributePart extends Part {
    element: Element;
    name: string;
    strings: string[];
    constructor(instance: TemplateInstance, element: Element, name: string, strings: string[]);
    setValue(values: any[]): void;
    readonly size: number;
}
export declare class NodePart extends Part {
    startNode: Node;
    endNode: Node;
    private _previousValue;
    constructor(instance: TemplateInstance, startNode: Node, endNode: Node);
    setValue(value: any): void;
    private _insertNodeBeforeEndNode(node);
    private _setNodeValue(value);
    private _setTextValue(value);
    private _setTemplateResultValue(value);
    private _setIterableValue(value);
    clear(startNode?: Node): void;
}
export declare class TemplateInstance {
    _template: Template;
    _parts: Part[];
    startNode: Node;
    endNode: Node;
    constructor(template: Template);
    readonly template: Template;
    update(values: any[]): void;
    _clone(): DocumentFragment;
    _createPart(templatePart: TemplatePart, node: Node): Part;
    _createInstance(template: Template): TemplateInstance;
}
declare global  {
    interface Node {
        __templateInstance?: TemplateInstance;
    }
}
export {};
